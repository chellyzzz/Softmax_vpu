[
  {
    "class":"firrtl.EmitCircuitAnnotation",
    "emitter":"firrtl.VerilogEmitter"
  },
  {
    "class":"firrtl.transforms.BlackBoxInlineAnno",
    "target":"top.ram_simulation",
    "name":"sram.v",
    "text":"\n  module ram_simulation #(\n      parameter                           ADDR_WIDTH = 32            ,\n      parameter                           DATA_WIDTH = 32            ,\n      parameter                           LATENCY = 2                 \n      )(\n      input clock,\n      input reset,\n    input           [  ADDR_WIDTH-1:0]                  sram_AXI_AWADDR ,\n    input                                               sram_AXI_AWVALID    ,\n    output                                              sram_AXI_AWREADY    ,\n    input           [   3:0]                            sram_AXI_AWID   ,\n    input           [   7:0]                            sram_AXI_AWLEN  ,\n    input           [   2:0]                            sram_AXI_AWSIZE ,\n    input           [   1:0]                            sram_AXI_AWBURST    ,\n    input           [  DATA_WIDTH-1:0]                  sram_AXI_WDATA  ,\n    input           [   3:0]                            sram_AXI_WSTRB  ,\n    input                                               sram_AXI_WVALID ,\n    output                                              sram_AXI_WREADY ,\n    input                                               sram_AXI_WLAST  ,\n    output          [   1:0]                            sram_AXI_BRESP  ,\n    output                                              sram_AXI_BVALID ,\n    input                                               sram_AXI_BREADY ,\n    output          [   3:0]                            sram_AXI_BID    ,\n    input           [  ADDR_WIDTH-1:0]                  sram_AXI_ARADDR ,\n    input           [   3:0]                            sram_AXI_ARID   ,\n    input                                               sram_AXI_ARVALID    ,\n    output                                              sram_AXI_ARREADY    ,\n    input           [   7:0]                            sram_AXI_ARLEN  ,\n    input           [   2:0]                            sram_AXI_ARSIZE ,\n    input           [   1:0]                            sram_AXI_ARBURST    ,\n    output          [  DATA_WIDTH-1:0]                  sram_AXI_RDATA  ,\n    output          [   1:0]                            sram_AXI_RRESP  ,\n    output                                              sram_AXI_RVALID ,\n    input                                               sram_AXI_RREADY ,\n    output          [   3:0]                            sram_AXI_RID    ,\n    output                                              sram_AXI_RLAST  \n      );\n \n  import \"DPI-C\" function void npc_pmem_read (input int raddr, output int rdata, input bit ren, input int len);\n  import \"DPI-C\" function void npc_pmem_write (input int waddr, input int wdata, input bit wen, input int len);\n  // AXI4LITE signals\n      reg             [ADDR_WIDTH-1 : 0]                  axi_awaddr  ;\n      reg                                                 axi_awready ;\n      reg                                                 axi_wready  ;\n      reg             [   1:0]                            axi_bresp   ;\n      reg                                                 axi_bvalid  ;\n      reg             [ADDR_WIDTH-1 : 0]                  axi_araddr  ;\n      reg                                                 axi_arready ;\n      reg             [DATA_WIDTH-1 : 0]                  axi_rdata   ;\n      reg             [   1:0]                            axi_rresp   ;\n      reg                                                 axi_rvalid  ;\n  //----------------------------------------------\n  //-- Signals for user logic register space example\n  //------------------------------------------------\n  //-- Number of Slave Registers 4\n      reg             [DATA_WIDTH-1:0]                    slv_reg0    ;\n      wire                                                slv_reg_rden    ;\n      wire                                                slv_reg_wren    ;\n      wire            [DATA_WIDTH-1:0]                    reg_data_out    ;\n      integer                                             byte_index  ;\n      reg                                                 aw_en   ;\n  // I/O Connections assignments\n  assign sram_AXI_AWREADY\t= axi_awready;\n  assign sram_AXI_WREADY\t= axi_wready;\n  assign sram_AXI_BRESP\t= axi_bresp;\n  assign sram_AXI_BVALID\t= axi_bvalid;\n  assign sram_AXI_BID     = 'b0;\n  assign sram_AXI_ARREADY\t= axi_arready;\n  assign sram_AXI_RDATA\t= axi_rdata;\n  assign sram_AXI_RRESP\t= axi_rresp;\n  assign sram_AXI_RVALID\t= axi_rvalid;\n  always @( posedge clock)\n  begin\n      if ( reset == 1'b0 )\n      begin\n          axi_awready <= 1'b0;\n          aw_en <= 1'b1;\n      end \n      else\n      begin    \n          if (~axi_awready && sram_AXI_AWVALID && sram_AXI_WVALID && aw_en)\n          begin\n              // slave is ready to accept write address when \n              // there is a valid write address and write data\n              // on the write address and data bus. This design \n              // expects no outstanding transactions. \n              axi_awready <= 1'b1;\n              aw_en <= 1'b0;\n          end\n          else if (sram_AXI_BREADY && axi_bvalid)\n              begin\n                  aw_en <= 1'b1;\n                  axi_awready <= 1'b0;\n              end\n          else           \n          begin\n              axi_awready <= 1'b0;\n          end\n      end \n  end       \n  always @(posedge clock) begin\n      case(sram_AXI_WSTRB)\n      4'b0001: begin  npc_pmem_write(axi_awaddr, sram_AXI_WDATA, slv_reg_wren, 1); end\n      4'b0011: begin  npc_pmem_write(axi_awaddr, sram_AXI_WDATA, slv_reg_wren, 2); end\n      4'b1111: begin  npc_pmem_write(axi_awaddr, sram_AXI_WDATA, slv_reg_wren, 4); end\n      default: begin \n          if(slv_reg_wren) begin\n              $display(\"SRAM WIRTE ERROR: should not reach here\");\n              $finish;\n          end\n      end\n      endcase\n  end\n  // Implement axi_awaddr latching\n  // This process is used to latch the address when both \n  // sram_AXI_AWVALID and sram_AXI_WVALID are valid. \n  always @( posedge clock )\n  begin\n      if ( reset == 1'b0 )\n      begin\n          axi_awaddr <= 0;\n      end \n      else\n      begin    \n          if (~axi_awready && sram_AXI_AWVALID && sram_AXI_WVALID && aw_en)\n          begin\n              // Write Address latching \n              axi_awaddr <= sram_AXI_AWADDR;\n          end\n      end \n  end      \n  // Implement axi_wready generation\n  // axi_wready is asserted for one clock clock cycle when both\n  // sram_AXI_AWVALID and sram_AXI_WVALID are asserted. axi_wready is \n  // de-asserted when reset is low. \n  always @( posedge clock )\n  begin\n      if ( reset == 1'b0 )\n      begin\n          axi_wready <= 1'b0;\n      end \n      else\n      begin    \n          if (~axi_wready && sram_AXI_WVALID && sram_AXI_AWVALID && aw_en )\n          begin\n              // slave is ready to accept write data when \n              // there is a valid write address and write data\n              // on the write address and data bus. This design \n              // expects no outstanding transactions. \n              axi_wready <= 1'b1;\n          end\n          else\n          begin\n              axi_wready <= 1'b0;\n          end\n      end \n  end       \n  // Implement write response logic generation\n  // The write response and response valid signals are asserted by the slave \n  // when axi_wready, sram_AXI_WVALID, axi_wready and sram_AXI_WVALID are asserted.  \n  // This marks the acceptance of address and indicates the status of \n  // write transaction.\n  always @( posedge clock )\n  begin\n      if ( reset == 1'b0 )\n      begin\n          axi_bvalid  <= 0;\n          axi_bresp   <= 2'b0;\n      end \n      else\n      begin    \n          if (axi_awready && sram_AXI_AWVALID && ~axi_bvalid && axi_wready && sram_AXI_WVALID)\n          begin\n              // indicates a valid write response is available\n              axi_bvalid <= 1'b1;\n              /*********/\n              axi_bresp  <= 2'b1; // 'OKAY' response \n              /*********/\n          end                   // work error responses in future\n          else\n          begin\n              if (sram_AXI_BREADY && axi_bvalid) \n              //check if bready is asserted while bvalid is high) \n              //(there is a possibility that bready is always asserted high)   \n              begin\n                  axi_bvalid <= 1'b0; \n                  /*********/\n                  axi_bresp  <= 2'b0; // 'OKAY' response \n                  /*********/\n              end  \n          end\n      end\n  end   \n  always @( posedge clock )\n  begin\n      if ( reset == 1'b0 )\n      begin\n          axi_arready <= 1'b0;\n          axi_araddr  <= 32'b0;\n      end \n      else\n      begin    \n          if (~axi_arready && sram_AXI_ARVALID)\n          begin\n              // indicates that the slave has acceped the valid read address\n              axi_arready <= 1'b1;\n              // Read address latching\n              axi_araddr  <= sram_AXI_ARADDR;\n          end\n          else\n          begin\n              axi_arready <= 1'b0;\n          end\n      end \n  end       \n  always @( posedge clock )\n  begin\n      if ( reset == 1'b0 )\n      begin\n          axi_rvalid <= 0;\n          axi_rresp  <= 0;\n      end \n      else\n      begin    \n          if (axi_arready && sram_AXI_ARVALID && ~axi_rvalid)\n          begin\n              // Valid read data is available at the read data bus\n              axi_rvalid <= 1'b1;\n              axi_rresp  <= 2'b1; // 'OKAY' response\n          end   \n          else if (axi_rvalid && sram_AXI_RREADY)\n          begin\n              // Read data is accepted by the master\n              axi_rvalid <= 1'b0;\n              axi_rresp <= 2'b0; // 'IDLE' response\n          end                \n      end\n  end    \n  assign slv_reg_rden = axi_arready & sram_AXI_ARVALID & ~axi_rvalid;\n  assign slv_reg_wren = axi_wready && sram_AXI_WVALID && axi_awready && sram_AXI_AWVALID;\n  always @(posedge clock)\n  begin\n      npc_pmem_read (axi_araddr, reg_data_out, slv_reg_rden, 4);\n  end\n  // Output register or memory read data\n  always @( posedge clock )\n  begin\n      if ( reset == 1'b0 )\n      begin\n          axi_rdata  <= 0;\n      end \n      else\n      begin    \n          // When there is a valid read address (sram_AXI_ARVALID) with \n          // acceptance of read address by the slave (axi_arready), \n          // output the read dada \n          if (slv_reg_rden)\n          begin\n              axi_rdata <= reg_data_out;     // register read data\n              // axi_rresp  <= 2'b1; // 'OKAY' response\n          end\n              // axi_rresp <= 2'b0; // 'IDLE' response\n      end\n  end    \n              endmodule\n            "
  },
  {
    "class":"firrtl.transforms.BlackBoxTargetDirAnno",
    "targetDir":"./build/"
  }
]